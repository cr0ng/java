# day 14

멤버 변수의 초기화
==> 멤버변수(Field)는 Heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있다.
	 
	 1. 명시적 초기화
	 ==> 변수를 선언하면서 값을 입력하는 방법
	 	가장 먼저 실행되는 방법
	 	
	 	예 ]
	 		class Test{
	 			int num = 100;	// 명시적 초기화
	 		}
	 		
	 2. 초기화 블럭을 이용한 초기화
	 ==> 이것은 인스턴스 변수에 대해서만 가능한 것으로
	 	두번째로 실행되는 방법
	 	
	 	형식 ]
	 		{
	 			이 안에 데이터를 변수에 입력
	 		}
	 	
	 	예 ]
	 		class Test{
	 			int num;
	 			...
	 			{ => 초기화 블럭
	 				num = 10; // 초기화 블럭을 이용한 초기화
	 			}
	 		}
	 		
	 3. static 블럭을 이용한 초기화
	 ==> 2번과 반대로 static 변수에 한해서만 가능한 방법
	 	두 번째로 실행되는 방법
	 	
	 	형식 ]
	 		static {	==> static 블럭
	 			데이터입력...
	 		}
	 		
	 	예 ]
	 		 class Test{
	 		 	static int num;
	 		 	...
	 		 	static {
	 		 		num = 50;
	 		 	}
	 		 }
	 		 
	 4. 생성자 함수를 이용한 초기화
	 ==> 가장 마지막에 실행되는 방법
	 
	 예 ]
	 	class Test{
	 		int num;
	 		
	 		public Test(){
	 			num = 200;
	 		}
	 	} 
	 			
-------------------------------------------------------------------------------------------------------

객체지향 언어의 특징
	
	1. 상속
	2. 다형성
	3. 은닉화/캡슐화 : 변수는 다른 클래스에서 접근하지 못하도록 하고
					   데이터를 꺼내거나 입력하는 작업은
					   함수를 만들어서 처리하도록 하는 방법
	 			
-------------------------------------------------------------------------------------------------------

상속
==> 이미 만들어진 클래스의 기능을 그대로 부여 받아서
	(==> 변수와 함수의 기능을 그대로 복사 받아서)
	새로운 클래스를 만드는 방법	
	
	이 개념이 나타나게 된 이유는
	소프트웨어의 개발 속도를 빠르게 하기 위한 한가지 방법
	
	즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로..
	
	객체 지향 언어는 부품 단위(클래스)로 프로그램을 만든 후
	그 부품을 조립해서 원한느 결과를 얻어내는 것이다.
	
	어디서 부품(클래스)을 구했는데
	그 기능이 사용자 마음에 꼭 맞지 않을 수 있다.
	그러면 처음부터 다시 만들어야 하는가?? 하는 문제에서
	이 문제점을 해결하기 위해서 만든 방법이 상속이다.
	 
	상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
	일단 그 기능을 모두 복사한 후
		1. 없는 기능은 덧붙이고
		2. 있는 기능 중 바꿀 내용만 바꾸자.
	라는 것이 상속
	
-------------------------------------------------------------------------------------------------------
★★★ : 반드시 외우기
상속의 형식]
	[접근지정자] [속성] class 클래스이름 extends 상속해줄클래스이름 {
		이 안에는 우리 눈에 안 보이더라도 상속해줄 클래스의 멤버들이 모두 포함
	}
	
	==> 따라서 상속을 받아서 만드는 클래스는 상속해주는 클래스보다 멤버(변수, 함수)가 늘어난다.	 
	 
	 ★★★
	 참고 ]
	 	자바는 오직 단일 상속만 가능
	 	==> 상속해주는 클래스는 한개여야만 한다.
	 	
	 예 ]
	 	
	 	class NewClass extends Old01, Old02{
	 	
	 	}
	 	==> 절대로 안된다.
	 	
	 	class NewClass extends Old01{
	 	}
	 	==> 정상적으로 상속이 된다.
	 	
	 용어정리 ]
	 	
	 	상속을 해준 클래스 - super Class, 상위클래스, 부모클래스
	 	상속을 받은 클래스 - sub Class, 하위클래스, 자식클래스
	 
	 is a		==> 상속 관계에 있는 클래스를 부르는 용어
	 	
	 				class Father {}
	 				class Son extends Father {}
	 				
	 				이 경우
	 					 Son in a Father
	 				가 성립됨
	 				
	 has a		==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
	 
	 				class Father {}
	 				class Son {
	 					Father f = new Father();
	 				}
	 
	 				이 경우
	 					 Son has a Father
	 				가 성립됨
	 
-------------------------------------------------------------------------------------------------------

 	상속 관계에 있는 경우 생상자의 역할
 	
 		결론 ]
 			 하위 클래스가 생성되는 순간
 			 상위 클래스가 자동 생성
 			 ==> 생성되는 순간 생성자 함수가 호출되므로
 			 	결국 하위 클래스를 생성하면
 			 		상위 클래스의 생성자 함수도 실행됨
 			 		
 	결론적으로 상위 클래스의 생성자 함수는 자동으로 호출되는 개념
 	자동 호출되는 경우는 무조건 기본 생성자만 이용하게 된다.
 	
 	참고 ]
 		기본생성자 : 매개변수가 없는 생성자
	 
	 ★★
	 참고 ]
	 	super()
	 		상위클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
	 		
	 		특징 ]
	 			1. 반드시 생성자 함수 안에서만 사용해야 한다.
	 			2. 반드시 첫줄 첫문자으로 사용해야 한다.
	 			
-------------------------------------------------------------------------------------------------------

★★★
함수의 오버라이딩(Overriding : 함수의 재정의)
==> 상속관계에 있는 하위 클래스에서
	상위 클래스가 가진 함수의 기능을 수정하는 행위
	
	방법 ]
	
		0.
		1. 상위 클래스가 가진 함수의 원형과 동일한 원형으로 만들어야 한다.
			참고 ]
				함수의 원형(Prototype)
					반환값타입 + 함수이름 + 매개변수리스트
		2. 접근지정자는 같거나 넓은 방향으로 한다.
		3. 예외처리는 같거나 좁은 방향으로 한다.
	 
	 이렇게 오버라이딩을 하면
	 내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용된다.
	 
	 예 ]
	 	class Fatehr{
	 		void abc(int a){
	 		}
	 	}
	 	
	 	class Son extends Father{
	 		void abc(int a){
	 			함수내용 수정...
	 			==> 기능을 변경...
	 		}
	 	}
	 		
★★★★★
참고 ]
	
	super
	==> this가 실행중인 객체 자기자신을 기억하는 예약된 변수이듯이
		super 역시 예약된 변수 중 하나로
		자신의 상위 클래스의 주소가 기억된 변수
		
	 	사용목적
	 		반드시 상위클래스의 멤버임을 밝혀야하하는 경우가 생길때 사용
	 		
------------------------------------------------------------------------------------------------------

★★★★★
참고 ]
	상속관계에 있는 클래스에서
	함수는 인스턴스쪽을 따르고
	변수는 레퍼런스 쪽을 따른다
	 
======================================================================================================

접근지정자
==> 그 내용을 어디까지 사용할 수 있게할 것인지를 지정하는 예약된 용어
	즉, 우리가 클래스를 만들면
	그 클래스를 모든 사람들에게 사용할 수 있게 공개해야되는 것은 아니다.	
	클래스를 제작하는 사람이 제작하는 클래스의 사용 범위를 지정할 수 있다.
	
	예 ]
		class는 누구까지 이 클래스를 사용하게 하도록 할까?
		new를 시킬 수 있도록 할 것인가?? 
	 	
	 	함수는 어디까지 이 함수를 호출할 수 있도록 할 것인가?
	 	
	 종류 ]
	 	
	 	1. private
	 	==> 절대로 다른 클래스에선 사용할 수 없고
	 		오직 자기자신 클래스 내에서만 사용할 수 있다.
	 		
	 	2. 생략
	 	==> 같은 패키지 소속의 클래스에서는 사용할 수 있다.
	 	
	 	3. protected
	 	==> 같은 패키지 소속의 클래스에서 그리고 상속받은 하위 클래스에서만 사용 가능
	 	
	 	4. public
	 	==> 모든 곳에서 사용 가능
	 	
	 참고 ]
	 	클래스에서는 public과 생략만 사용할 수 있다.
	 		
	 참고 ]
	 	클래스의 접근지정의 의미는 클래스 자체를 사용할지 여부를 지정하는 것이고
	 	생성자함수의 접근지정의 의미는 new 시킬 수 있는지 여부를 지정하는 것이다.
	 	
은닉화
==> 프로그램에 있어서 가장 중요한 요소는 데이터이다.
	즉, 변수가 프로그램에서 핵심적인 요소가 되는 것이다.
	무결성 데이터를 유지할 수 있는것이 가장 중요한 개념이 된다.
	
	은닉화란?
	이처럼 중요한 요소인 변수를 사용자가 함부로 변경하지 못하도록
	(결점이 있는 데이터가 오지 못하도록 하는것)
	방지하는 기법을 은닉화
	 	
	 	
	 	
	 	
=============================================================================================
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 	
	 
	 
	 
	 