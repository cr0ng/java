# day20

Map
==> 하나의 데이터를 그 데이터를 구분할 수 있는
	키값과 한 쌍으로 만들어서 데이터를 기억하는 컬렌셕의 일종
	그리고 사용할 경우에는 키값을 이용해서 데이터를 꺼내를 수 있도록 한 것
	
	Map 계열은 많은 양의 데이터를 보관하는 용도 보다는
	데이터를 손쉽게 구분하여 사용할 목적으로 사용됨
	
Hashtable / HashMap

	Hashtable이 구 버젼, HashMap이 나중에 나온 클래스
	
	내부적으로 키값을 해쉬 테이블을 이용해서 정렬해서 보관
	
	주요함수
		put(Object key, Object value)
		==> 데이터를 입력하는 함수
		
		get(Object key)
		==> 필요한 데이터를 꺼내는 함수
		
		참고 함수	
			
			values()
			==> 데이터만 꺼내서 반환해주는 함수
			
			keys()
			==> 키값만 꺼내서 반환해주는 함수 (Hashtable에만 존재하는 함수)
			
			keySet()
			==> 키값만 꺼내서 반환해주는 함수 (Hashtable, HashMap 둘 다 사용할 수 있음. Map 계열에서는 모두 사용가능)
			
			entrySet()
			==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
				==> 키값은 데이터를 Set으로 묶어주는 함수
				
				주의 ]	
					Map은 항상 키와 벨류 두 개가 있어야 저장됨
					Set은 데이터 한 개만 있으면 저장됨
					따라서 키값과 데이터를 하나로 묶어야만
					Set에 저장이 된다.
					
					이 때 이 문제를 해결하기 위한 클래스(VO 클래스)가 존재
					그 클래스가 바로 Map.Entry
					== 이 클래스 안에는 key와 value 변수를 은닉화 시켜놓고
						이 변수를 사용할 수 있는 함수를 제공함으로써
						두 개의 변수를 하나로 묶어 놓은 클래스
						
TreeMap
==> TreeSet도 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다
	이 때 정렬 기준은 키값을 이용해서 정렬하게 된다.
	따라서 키값이 정렬이 되지 않는 클래스는 사용할 수 없고
	필요하다면 정렬 방식을 정해서 사용해야 한다.
	
	Tmp abc(){
		int a = 10;
		String b = "홍길동";
		Tmp t = new Tmp();
		t.a = a;
		t.b = b;
		
		return t;
					
	}
	
	==>
		이처럼 클래스를 보면 가끔은 무슨 기능을 필요로 해서 만들어지는 것이 아니고
		여러개의 데이터를 하나로 묶기 위한 목적으로 만들어 놓은 클래스가 있다.
		
		class Tmp{
			int a;	
			String b;
		}
		
		이런 클래스를 우리는 데이터 빈 클래스라고도 하고
		Value Object(VO)라고도 함
		DTO(Data Transfer Object)라고도 부름
		
-----------------------------------------------------------------------------------------------------
참고 ]
	컬렉션 안에는 다시 컬렉션을 입력할 수 있다.
	
		컬렉션 안에는 모든 클래스를 입력할 수 있으므로
		컬렉션도 클래스이므로 저장이 가능
		
=====================================================================================================
Properties
==> Map의 역할을 하는 클래스

	일반 Map과의 차이점은 파일(외부장치)를 이용해서 직접 데이터를 읽어서 Map처럼 저장할 수 있고
	Map에 저장된 데이터를 직접 파일(외부장치)로 출력해서 저장할 수 있다.
	
	주의사항]
		★★★
		파일의 내용을 읽을 때 엔코딩이 되지 않는다.
		==> 한글 파일의 경우 파일 자체에서 엔코딩을 하지 않으면
			내용이 한글인 경우 한글이 깨져서 들어온다.
			
		==>
		해결방법 ]
			한글이 포함된 파일을 Properties에서 사용하기 위해서 엔코딩 시키는 방법
				
				1. cmd 창을 연다.
				2. path를 자바 home으로 잡아준다.
				3. native2ascii 기능을 이용해서 엔코딩 해준다.
				
					형식 ]
						native2ascii 인코딩할파일 저장될파일
						
	참고 ]
		Properties 클래스는 오직 String 으로만 키값과 데이터를 처리해야 함
		
	참고 ]
		Properties는 이 외에도 하나의 특징을 가지고 있는데
		현재 프로그램의 정보를 Map으로 자동 처리하는 기능을 가짐
			
==================================================================================================
제너릭스
==> 컬렉션은 모든 형태의 데이터를 다 입력받을 수 있다.
	하지만 실무에서는 한가지 형태로 입력받는 것을 원칙으로 한다.
	이 때 꺼낼때는 항상 형변환을 해서 꺼내야한다.			
	즉, 한가지 형태로 데이터를 입력해 놓았는데
	꺼낼때는 자동 형변환이 일어나지 않기때문에 항상 강제형변환을 해줘야 한다.
	
	제너릭스란?
	==> 컬렉션에 입력하는 데이터를 미리 알려줌으로써
		나중에 꺼내서 쓸 때 좀 더 편하게 (강제형변환없이) 꺼낼 수 있도록 해주는 것.
	
	형식 ]
		ArrayList<String> list = new ArrayList<String>();
		==> 이 때 list에는 문자열 데이터만 입력할 수 있게 된다.
			꺼낼 때는 자동으로 문자열 타입으로 꺼내게 된다.
			
	참고 ]
		반드시 컬렉션마다 모두 제너릭스 선언을 해줘야 한다.
		
	참고 ]
		제너릭스는 전파되지 않는다.
		하나의 컬렉션이 제너릭스 선언이 되었더라도
		그 컬렉션을 이용하는 다른 컬렉션은 제너릭스를 잊어버린다.
		따라서 새로운 컬렉션도 다시 제너릭스 선언을 해줘야 한다.
		
	참고 ]
		특수한 제너릭스
			원래 제너릭스는 특정 클래스만 입력받을 목적으로 사용된다.
			
			형식 ]
			
				<? super 클래스이름>
				==> 지정한 클래스포함 상위 클래스까지 허락
			
				<? extends 클래스이름>
				==> 지정한 클래스포함 하위 클래스까지 허락
		
			이 방법은 제너릭스를 선언하지 않은것과 동일한 효과
	
========================================================================================
어노테이션
==> 내부적으로 약속된 실행을 자동으로 처리하도록 하는 명령의 일종
	주로
		화면에 실제 보이는 실행이 아니고
		점검을 한다던지,
		선언적인 실행(이 클래스는 어떻게 동작하세요)
		의 의미를 가진 명령 말함
		
	형식 ]
		@명령
		
		
		
		
		
		
		
		
		

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	