# day19

컬렉션(Collection)
==> 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합

	배열을 이용해서도 많은 양의 데이터를 보관할 수 있지만
	단점
		1. 크기를 변경할 수 없다.
			( 즉, 한번 데이터의 양을 정하면 그 양보다 많은 데이터는 보관할 수 없다.)
		2. 데이터의 입출력에 많은 제약을 갖는다.
			(반드시 위치를 알아야 데이터 입출력이 가능하다.)
			
종류
	
	1. List 계열
		특징
			1) 입력한 순서를 보장한다.(처리 속도가 느리다.)
			2) 중복 데이터(같은 데이터)도 다시 저장할 수 있다.
			
	2. Set 계열
		특징
			1) 입력한 순서를 보장하지 않는다.
				(나름의 규칙에 의해서 데이터를 정렬해서 보관한다.
					따라서 처리속도가 빠르다.)
			2) 중복 데이터가 다시 저장되면 먼저 입력된 데이터를 삭제한 후 저장한다.
				==> 중복 데이터는 한번만 저장한다.
	
	3. Map 계열
		특징 
			1) 데이터를 그 데이터를 구분하는 키값과 한쌍을 만들어서 저장한다.
			2) 입력 순서는 보장하지 않는다.
			3) 같은 키값이 입력되면 먼저 데이터는 삭제한다.
				(즉, 데이터가 같아도 상관없지만 키값은 같으면 안된다.)
				
참고 ]
	List 계열과 Set 계열은 상위 클래스가 같다.
	Map 계열은 상위클래스가 다르다.
	List와 Set은 다형성 처리가 가능하지만(서로 변환이 가능하다.)
	Map은 독립적이므로 변환이 불가능하다.
	
--------------------------------------------------------------------------------------------------------------------
List 계열
	
	1. Vector
		==> 내부적으로는 배열 형태를 만들어서 데이터를 보관하는 컬렉션의 한 종류이다.
			
			장점 ]
				입력속도와 검색 속도가 빠르다.
				
			단점 ]
				중간에 데이터를 추가하거나, 데이터를 삭제하는 속도는 느리다.
			
			결론 ]
				데이터의 변화가 거의 없는 프로그램에서 많이 사용된다.
				
		생성방법
			
			1) Vector()
				==> 배열의 크기를 10으로 정한 상태로 벡터를 만들어 준다.
					데이터가 크기보다 많아지면 변경이 된다.
					
			2) Vector(Collection c)
				==> 다른 컬렉션의 데이터를 복사해서 벡터를 만들어준다.
			
			3) Vector(int initialCapacity)
				==> 사용자가 직접 배열의 크기를 정하면서 벡터를 만든다.
			
			* 권장
			4) Vector(int initialCapacity, int capacityIncrement)
				==> 3) + 데이터의 양이 많으면 추가할 배열의 크기를 정한다.
				
			참고 ]
				컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력 받을 수 있다.
				이때 데이터를 입력 받을 공간을 확보해야 하는데
				규칙이
					현재공간 * 2
				가 된다.
				
				
		주요함수
			1. 데이터를 입력하는 함수
				add(Object e)
				add(int index, Object element)
				addAll(Collection c)
				addAll(int index, Collection c)
				addElement(Object obj)
				insertElementAt(Object obj, int index)
				
			2. 데이터를 수정하는 함수
				set(int index, Object element)
				setElementAt(Object obj, int index)
				
			3. 데이터를 꺼내는 함수
				get(int index)
				elementAt(in index)
				firstElement()
				lastElement()
				elements()

	참고 ]
		E, V, K 라고 표현된 것은 Object 를 의미하는 제너릭스 용어이다.
		
----------------------------------------------------------------------------------------------------------------
ArrayList
==> Vector 의 신버젼
	역시 배열 형태로 데이터를 관리하기 때문에
	Vector의 특징을 그대로 가지고 있다.
	다만, 스레드에서 동기화 처리를 자동으로 해주기때문에
	최근엔 Vector보다는 ArrayList 를 선호한다.
	
	사용방법 역시 Vector와 유사하다.
	
	참고 ]
		List 계열의 주소를 출력하면
		마치 데이터가 나온것처럼 보이지만
		이것은 toString() 함수를 오버라이드 해놓아서 출력만 될 뿐이다.
		절대로 데이터를 사용하는 개념은 아니다.

-----------------------------------------------------------------------------------------------------------------
LinkedList
	==> 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 방식의 컬렉션의 일종이다.
		
		장점 ]
			데이터를 중간에 끼워넣기 작업, 삭제 작업은 속도가 빠르다.
			
		단점 ]
			데이터를 누적시키는 작업은 속도가 느리다.
			
		주로 데이터의 변화가 심한 경우에 많이 사용되는 컬렉션이다.

-----------------------------------------------------------------------------------------------------------------
Collections 클래스
	==> 이름은 컬렉션이지만 컬렉션을 관리하는 클래스는 아니고
		컬렉션을 이용할 때 필요한 부가적인 기능들을 모아놓은 유틸리티 클래스이다.
		
		주의사항
			List를 달라고 하면 List 계열을 주면 된다.
			Set을 달라고 하면 Set계열의 클래스를 주면 된다.
			Collection을 달라고 하면 List나 Set 계열의 클래스를 주면된다.
			Map을 달라고 하면 Map 계열의 클래스를 주면 된다.
			
		참고 ]
			일반적인 정렬은 오름차순 정렬을 하게 된다.
			만약 정렬방식을 변경하고 하면
			그때는 정렬방식을 알려주고 정렬을 해야한다.
				
				sort(List list, Comparator c)
			를 사용하면 된다.
			
----------------------------------------------------------------------------------------------------------------
Set 계열
	특징 ]
		1. 입력순서를 보장하지 않는다.
			( <== 나름의 규칙에 따라서 내부적으로 정렬을 해서 보관한다.)
		2. 중복된 데이터는 허용하지 않는다.
			( 같은 데이터가 다시 저장되면 먼저 데이터를 지우고,
				새로운 데이터를 입력한다.)
				
1. HashSet
	==> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션
		따라서 우리가 상상하는 정렬이 이루어지지 않는다.
		
		생성자 
			HashSet(int initialCapacity, float loadFactor)
				loadFactor :  해쉬코드값을 만드는 규칙에 사용할 상수값을 
								사용자가 지정하면서 해쉬테이블을 만들어서 사용한다.
								
	*****
	참고 ]
		Set 계열은 데이터를 꺼내는 기능이 존재하지 않는다.
		==> 왜??
			사용자가 데이터가 저장된 장소를 모르기 때문에
			특정위치를 지정하면서 데이터를 꺼낼 수 없다.
			
			따라서 Iterator로 변환해서 순차적으로 꺼내서 사용해야 한다.
			마치 StringTokenizer 처럼 꺼내야 한다.
			
2. TreeSet
	==> 내부적으로 Tree Sort 라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가진 컬렉션
	
		특징 ]
			우리가 상상하는 정렬 방식을 이용한다.
			
		생성자 ]
			TreeSet(Comparator comparator)
			==> 정렬 방식을 변경해서 TreeSet을 만드는 방법
			
			TreeSet(Sorted<E> s)
			==> TreeSet을 이용해서 다시 TreeSet을 만든다.
			
		참고함수 ]
			
			subSet()
			==> 하나의 Set에 담긴 내용중에서 특정 부분만 골라서 새로운 Set 만드는 함수
			
			headSet(E toElement)
			==> 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다.
			
			tailSet(E fromElement)
			==> 지정한 부분부터 마지막까지 골라서 새로운 Set을 만든다.
			
			
----------------------------------------------------------------------------------------------------------------
Iterator
==> 컬렉션은 많은 클래스들의 집합이고 그 형태도 다르다.
	하지만 이들은 서로 혼용될 수 있다.
	그런데 그 안에 데이터를 꺼내는 방식은 약간씩 다르다.
	List에서 데이터를 꺼내는 방식과 Set에서 데이터를 꺼내는 방식이 다르다.
	(꺼내는 소스를 다르게 만들어야 한다.)
	
	따라서 데이터를 꺼내기 위해서만 사용하는 클래스를 따로 만들어 놓았다.
	그 클래스가 Iterator 이다.
	즉, List, Set 모두 Iterator 로 변환시키면 
	모두 같은 방식으로 꺼낼 수 있게 된다.
	따라서 꺼내는 소스를 동일하게 사용할 수 있게 된다.
	
	특징 ]
		StringTokenizer와 유사하게
		순차적으로만 꺼낼 수 있고
		한번 꺼낸 데이터는 자동 삭제된다.
		
***
참고 ]
	List 계열의 클래스는 컬렉션을 입력받아서 객체로 만들 수 있다.
	따라서 Set 계열의 데이터를 꺼낼때 Iterator 를 사용하지 않고
	List계열로 만든 후 순차적으로 꺼내는 방법도 있다.